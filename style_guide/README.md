When you learn how to write clean code, just like writing an essay, you need to find a style that works for you. There is no single "right way." The most important thing is to be consistent. Here are a few tips to help you get started:

1. Variable naming conventions. Find names for your variables that are as specific as possible without making them too specific. This is easier said than done. I see a lot of `my_data` a lot, and that is overly general. But something like `ferret_tx` may be too specific, because if you'd ever want to swap that out for mouse, the variable name will no longer be accurate. A reasonable name is `animal_tx`, because it's more specific than ferret, but less specific than `ref_tx`. It all depends on context. Note that although `tx` by itself would work, because it is so short, it becomes hard to search, and I would avoid using short variable names. There are two exceptions to this rule. One is if that variable is the ONLY one of its kind in the script and is referenced very often. For example, if a script is only ever going to handle one dataframe, then `df` is an acceptable name. The other example is if the variable is something that is one-and-done. In that case, it's acceptable to name it something nondescriptive, such as `tmp`, `cols`, `files`, etc. to signal that these variables are not important. As for snake\_case vs. CamelCase, either is acceptable, so pick one and stick with it. The only thing that is unacceptable is to switch back and forth between the two. Sometimes it's unavoiable, because say you've written your code in snake\_case, but the library you're importing from uses CamelCase. This scenario is acceptable as long as you stick to your convention, do not switch just because the library you're importing has a different convention.
2. Properly formatting your code. You can use whitespaces, newlines, and indentations to make sure things are readable. A general rule-of-thumb is that lines should not extend past 80 characters, because then you'd have to scroll sideways to read them. Most of your code should fit on the screen, and the only direction you should have to scroll is up or down. If you have a bunch of arguments in a function, you can put each argument on its own line and close the function on the last line. Although this makes your document longer (ie. stretching a 1 line code into 5+ lines), it makes the document far more readable. Could you imagine reading a newspaper if they didn't split the text into multiple columns and the sentences just went across the entire page?
3. Properly documenting your code. The example scripts that Dan provides include a ton of code explanations. This may mislead beginners into thinking that properly documenting code means writing a ton of comments explaining how the code works, but this will actually just lead to clutter and make your code difficult to read. Properly written code are as self-explanatory as possible, and code comments should only convey the intent, ie. explain why a function or design was chosen and potential pitfalls, not how the code works line-by-line. For that, the user is typically expected to read StackOverflow or the documentation on the function. Here's a good article explaning the concept: [Best practices for writing code comments](https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/).
4. Abstracting away complexity. If you find that you need many lines of code to achieve a singular goal, you should wrap it in a function. For example, suppose you have 20 csv files that you are processing. When you import these csv files, you need to rename the column names, properly format a datetime column, and force another column to be an integer datatype instead of float, and you need to do this multiple times. Rather than leaving each item like that, wrap it in a `preprocess_data` function, and now  when the reader reads that section, they can instantly understand your intent without ever having to write code comments. Building on this, it is possible to write an R script that calls another R script with slightly differernt parameters, which prevents code duplication.
5. Hardcoding vs. parameters. When possible, always try to write your code in a way that hard-coded paths can be easily substituted. This means putting it in a command line argument that is easily accessible.

Antipatterns to avoid:

1. code duplication
2. hard-coding: paths, data, column names, etc.
3. missing references: lines of code references objects instantiated in other scripts
4. lack of modularity: data and figures are all input and output into the same directory, making it difficult to figure out which files are used
5. manual intervention: instead of using `ggsave()` or `png() plot() dev.off()`, the script expects you to run each line in RStudio and use the [Export] button, making figure generation non-deterministic
6. improper object instantiation: filtered dataframes or data subsets are saved in permanent variables, signaling they might be important, but then they are never used again
7. lack of abstraction: try to wrap commonly used code in reusable functions that are appropriately named
8. improper scoping: importing entire tidyverse takes up a lot of memory and often makes it confusing to figure out which package your specific function comes from, unless you have an R terminal open
9. improper variable names: name your variables something descriptive and searchable

It is important to you try your best to avoid emulating these antipatterns. If you find yourself pressed for time and have to use an antipattern, always go back and clean it up after the deadline. This allows you to prevent accumulating technical debt, which if left unaddressed, will eventually cause you to never use your code again.
